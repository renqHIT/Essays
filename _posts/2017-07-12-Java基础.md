# Java基础

标签（空格分隔）： Java

---

JAVA基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解

## 一、IO

参考资料：http://tutorials.jenkov.com/java-io/index.html

Java IO主要处理的内容是各种输入输出，例如文件，网络流，内存缓冲区，等。Java NIO是另外一个IO库，这个库也提供IO功能和网络API，但是NIO可以在非阻塞模式工作。非阻塞IO在一些场景比阻塞IO有明显的性能提升。

### 1. Overview

 - 文件
 - 管道
 - 网络链接
 - 内存缓冲区
 - System.in, System.out, System.error

**IO流**是Java IO的核心概念，流或者可以读，或者可以写；流或者是基于字节，或者是基于字符；

Java IO包含许多InputStream, OutputStream, Reader和Writer的子类，它们各自有不同的目的，主要目的如下：

 - 文件访问
 - 网络访问
 - 内存缓冲区访问
 - 进程间交互
 - 缓冲区
 - 过滤
 - 解析
 - 读写文本
 - 读写原生类型（long，int等）
 - 读写对象

|||基于字节输入|基于字节输出|基于字符输入|基于字符输出|
|--|--|--|--|--|
|基类|InputStream|OutputStream|Reader、InputStreamReader|Writer、OutputStreamWriter|
|数组|ByteArrayInputStream|ByteArrayOutputStream|CharArrayReader|CharArrayWriter|
|文件|FileInputStream、RandomAccessFile|FileInputStream、RandomAccessFile|FileReader|FileWriter|
|管道|PipedInputStream|PipedOutputStream|PipedReader|PipedWriter|
|缓冲区|BufferedInputStream|BufferedOutputStream|BufferedReader|BufferedWriter|
|过滤|FilterInputStream|FilterOutputStream|FilterReader|FilterWriter|
|解析|PushbackInputStream、StreamTokenizer||PushbackReader、LineNumberReader||
|字符串|||StringReader|StringWriter|
|数据|DataInputStream|DataOutputStream|||
|格式化的数据||PringStream||PringWriter|
|工具|SequenceInputStream||||

 
### 2. 文件

### 3. 管道

管道例子

```
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class PipeExample {

    public static void main(String[] args) throws IOException {

        final PipedOutputStream output = new PipedOutputStream();
        final PipedInputStream  input  = new PipedInputStream(output);


        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    output.write("Hello world, pipe!".getBytes());
                } catch (IOException e) {
                }
            }
        });


        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    int data = input.read();
                    while(data != -1){
                        System.out.print((char) data);
                        data = input.read();
                    }
                } catch (IOException e) {
                }
            }
        });

        thread1.start();
        thread2.start();

    }
}
```
注意，当使用两个连接的管道流，给一个流一个线程，另外一个流另一个线程。流的read()和write()调用是阻塞的，就是说如果你用一个线程同时读和写，那这个线程就会产生死锁。

### 4. 网络

### 5. 二进制、字节数组

### 6. System.in System.out System.error

### 7. TO BE ADDED

## 二、多线程

TODO: add introduction

### 1. 线程的生命周期

![线程生命周期][1]

 - New
 - Runnable
 - Waiting
 - Timed Waiting
 - Terminated（Dead）

### 2. 通过实现一个Runnable接口创建线程

```
class RunnableDemo implements Runnable {
   private Thread t;
   private String threadName;
   
   RunnableDemo( String name) {
      threadName = name;
      System.out.println("Creating " +  threadName );
   }
   
   public void run() {
      System.out.println("Running " +  threadName );
      try {
         for(int i = 4; i > 0; i--) {
            System.out.println("Thread: " + threadName + ", " + i);
            // Let the thread sleep for a while.
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println("Thread " +  threadName + " interrupted.");
      }
      System.out.println("Thread " +  threadName + " exiting.");
   }
   
   public void start () {
      System.out.println("Starting " +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      RunnableDemo R1 = new RunnableDemo( "Thread-1");
      R1.start();
      
      RunnableDemo R2 = new RunnableDemo( "Thread-2");
      R2.start();
   }   
}
```

### 3. 通过继承Thread类创建线程
 
```
class ThreadDemo extends Thread {
   private Thread t;
   private String threadName;
   
   ThreadDemo( String name) {
      threadName = name;
      System.out.println("Creating " +  threadName );
   }
   
   public void run() {
      System.out.println("Running " +  threadName );
      try {
         for(int i = 4; i > 0; i--) {
            System.out.println("Thread: " + threadName + ", " + i);
            // Let the thread sleep for a while.
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println("Thread " +  threadName + " interrupted.");
      }
      System.out.println("Thread " +  threadName + " exiting.");
   }
   
   public void start () {
      System.out.println("Starting " +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      ThreadDemo T1 = new ThreadDemo( "Thread-1");
      T1.start();
      
      ThreadDemo T2 = new ThreadDemo( "Thread-2");
      T2.start();
   }   
}
```
 
### 4. 线程同步

参考：https://www.tutorialspoint.com/java/java_multithreading.htm

多个线程需要同时访问一个资源时，我们需要控制多个线程的访问，同一时刻只能有一个线程访问某项资源。这是通过**monitors**的概念实现的。每个Java对象都和一个monitor相关联，一个线程可以加锁、解锁这个monitor。在一个时刻，只能有一个线程拥有一个monitor的锁。

Java语言提供了一个创建线程并同步任务的方式，**synchronized块**。你可以将共享的资源放到这个块里。下面是synchronized语句的一般形式

```
synchronized(objectidentifier) {
   // Access shared variables and other shared resources
}
```


多线程同步的例子

```
class PrintDemo {
   public void printCount() {
      try {
         for(int i = 5; i > 0; i--) {
            System.out.println("Counter   ---   "  + i );
         }
      }catch (Exception e) {
         System.out.println("Thread  interrupted.");
      }
   }
}

class ThreadDemo extends Thread {
   private Thread t;
   private String threadName;
   PrintDemo  PD;

   ThreadDemo( String name,  PrintDemo pd) {
      threadName = name;
      PD = pd;
   }
   
   public void run() {
      synchronized(PD) {          // 注意这一行的synchronizedW
         PD.printCount();
      }
      System.out.println("Thread " +  threadName + " exiting.");
   }

   public void start () {
      System.out.println("Starting " +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      PrintDemo PD = new PrintDemo();

      ThreadDemo T1 = new ThreadDemo( "Thread - 1 ", PD );
      ThreadDemo T2 = new ThreadDemo( "Thread - 2 ", PD );

      T1.start();
      T2.start();

      // wait for threads to end
      try {
         T1.join();
         T2.join();
      }catch( Exception e) {
         System.out.println("Interrupted");
      }
   }
}
```
x
### 5. 线程间通信
 
## 三、集合

## 四、JVM原理                                                                                                 


  [1]: https://www.tutorialspoint.com/java/images/Thread_Life_Cycle.jpg
