# 以太坊白皮书

作者 Vitalik Buterin
整理 renqHIT

## 摘要

当中本聪在2009年1月首次提出比特币区块链时，他同时引入了两个激进且未测试的概念。第一个是“比特币”，一个去中心、点对点的在线货币系统，没有人背书，没有内在价值，没有中心发行人。到目前为止，比特币作为数字货币已经引起了公众的大量注意，既在“没有中央银行的货币”的政治层面，也在其价格极度上下波动层面。然而中本聪的伟大实验，还有一个和比特币同等重要的方面：基于工作量证明的区块链概念，这个概念让公众在合约上达成一致。比特币作为一项应用，可以描述为一个first-to-file系统：如果一个实体拥有50个比特币，同时给A和B发送50个比特币, 只有首先得到确认的交易会执行。本质上没有办法判断哪个交易来的更早，这个问题长期以来一直困扰着去中心数字货币的开发。中本聪的区块链时第一个可信的去中心化解决方案。现在，人们开始将注意力转移到比特币技术的第二个方面，除了货币，我们还能应用区块链技术做什么。

一般应用包括用数字资产去做自定义货币（山寨币），做物理设备所有权证明（智能资产），不可替代资产（如域名）所有权证明，做去中心交易，金融衍生品，做点对点赌博，做区块链身份和征信系统。另一个重要探索领域是“智能合约”：一个按照预设规则自动转移数字资产的系统。例如，某人有一项财务合同“A每天可以提取最多X个货币单位，B每天可以提取最多Y个货币单位，A和B一起可以提取任意，A可以关闭B的提取权限”。这个去中心化自制组织的逻辑扩展，即长期智能合约，拥有资产并且制定整个组织的规则。以太坊（Ethereum）提供的是一个内置完整功能的，图灵完备的编程语言，它可以用来创建“编码任意状态转移函数的合约”，通过编写几行代码，以太坊即可支持用户创建上面提到的各种系统，以及其他未想到的系统。

## 历史

## 比特币：作为状态转移系统

传统的交易系统是一个状态转移系统，交易TX将系统状态S转移为状态S'

![比特币状态转移图][1]

```
APPLY(S, TX) -> S' or ERROR
```

具体地，转账成功

```
APPLY({ Alice：$50, Bob: $50 }, "从Alice转账给Bob $20") = { Alice: $30, Bob: $70 }
```
转账失败

```
APPLY({ Alice: $30, Bob: $50}, "从Alice转账给Bob $70") = ERROR
```


在比特币中，**状态**是已经挖到但没有花掉的币的集合（技术上讲，是“未消费的交易输出”，UTXO），每个UTXO拥有一个面值和一个拥有者（定义为一个密码学公钥，20字节的地址）。一份交易包含一个或多个输入，每个输入包含一个指向一个存在的UTXO的引用，包含一个密码学签名(由拥有者地址关联的私钥产生)；一份交易还包括一个或多个输出，每个输出包含一个新的UTXO，等待加到状态中。**状态转移函数** APPLY(S,TX) -> S'可以粗略地定义为：

```
1. 对每个TX:
  i. 如果引用的UTXO不在S中，返回错误
  ii.如果提供的签名不匹配UTXO的拥有者，返回错误
2. 如果索引输入UTXO的面值之和小于输出的UTXO面值之和，返回错误
3. 返回状态S，所有输入的UTXO被删除，所有输出的UTXO被加上
```

第一步阻止交易发送方花费不存在的币，阻止交易发送方花费其他人的币；第二步保护面值。协议是这样工作的，假设Alice想要给Bob发送11.7个比特币，首先，Alice寻找她自己可用的UTXO的集合，面值之和不小于11.7个比特币。现实中，Alice不会得到正好11.7个比特币，假如她能得到最小的面值之和是6+4+2=12。**TODO：以下内容省略**

## 挖矿

![挖矿][2]

如果我们能访问到一个可信赖的中央服务，实现上面的系统是没营养的，可以按照上面列举的步骤进行编码。然而在比特币中，我们要构建一个去中心的货币系统，因此我们需要将上面的状态转移系统和一个共识系统结合起来，确保所有人在交易顺序上达成一致。比特币的去中心共识过程需要网络中的节点持续地产生交易数据包，称作“区块”。网络倾向于每10分钟产生一个区块，每个区块包含一个时间戳，一个nonce（密码学中指只被使用一次的随机数），一个指向前一个区块的哈希指针，一个交易列表，包含从上个区块起发生的交易。随着时间进行，这个过程产生了一致的，持续增长的“区块链”，保持更新比特币账本的最新状态。

检查一个区块是否合法的算法如下：
```
1. 检查前一个区块是否存在，是否合法
2. 检查当前区块的时间戳是否大于前一个区块且小于未来两小时
3. 检查当前区块的工作量证明是否合法
4. 令S[0]是前一个区块结束时的状态
5. 设TX是当前区块的交易列表，包含n个交易。对每个i从0到n-1，令S[i+1] = APPLY(S[i], TX[i]), 如果任意一个交易返回错误，报错退出
6. 返回成功，令状态S[n]为当前区块结束时的状态
```

上面列出的验证条件中，“工作量证明”是其他系统没有的。准确的条件是，每个区块的双重-SHA256哈希值（是一个256位的数字），必须小于一个动态调整的目标，产生这个动态目标的时间近似为2^187。这样做的目的是让产生区块变得难计算，从而阻止“Sybil攻击”更改整个区块链。因为SHA256设计上是一个完全难以预测的伪随机函数，因此唯一的创建区块的办法就是重复试错。

在当前约2^187的目标情况下，网络在找到一个合法区块前必须平均尝试约2^69次；总的来说，目标在每2016个区块产生后重新调整，从而达到平均每过10分钟，网络就可以找到一个新的区块。为了补偿矿工做的这些计算工作，每个区块的矿工可以得到新产生的12.5个比特币的奖励。另外，如果任何交易的输入大于其输出总和，差价会送给矿工，作为交易费。顺便提下，比特币初始状态没有任何币，挖矿是产生比特币的唯一机制。

为了更好地理解挖矿的目的，我们考虑下恶意攻击事件下会发生什么。由于比特币底层加密公认是安全的，攻击者会将攻击目标对准加密系统未直接保护的部分：交易顺序。攻击策略比较简单：

```
1. 给某个商人付100比特币，购买某种产品（最好是运输迅速的数字商品）
2. 等待产品运输
3. 制造另外一笔交易，给自己发送100比特币
4. 向网络证明发送给自己的交易首先发生
```

一旦步骤1已经发生，几分钟后某个矿工就会在一个区块中包含这笔交易，假如是270000号区块。过了大概1小时，在这个区块后面又加入了5个区块，每个区块都间接地指向这笔交易，从而确认交易。在这一点，商人会接受付款，开始发货；我们假设产品是个数字商品，发货立刻完成。现在，攻击者创建了另外一笔交易，给自己发送100比特币。如果攻击者向网络中播报这笔交易，交易不会被处理；矿工会执行APPLY（S,TX），注意TX消费了一个不再存在的UTXO。攻击者从此将比特币区块链“分叉”，开始挖掘另外一个版本的270000号区块，指向同一个父节点269999号区块，但是更换了最后一笔交易。由于区块数据不一样，需要对这个区块重新开始工作量证明。更进一步，攻击者新的270000号区块有一个不同的哈希值，所以原有的270001到270005号区块不在指向它。这样，原有区块链和攻击者的新区块链彻底分离。由于比特币规则是相信最长的区块链，所以合法的矿工会继续在270005号区块后面工作，只有攻击者自己在270000链后面工作。为了让攻击者的链更长，攻击者需要拥有大于50%的计算能力，才能追赶上原有的链(即“51%攻击”)。一个拥有巨大计算能力的攻击者可以做到重做工作量证明（PoW），然而中本聪的论文也提到，在合法区块中挖矿得到的收益要远大于破坏这个网络。

## Merkle树

用Merkle树的原因：Merkle树可以用一小块数据，证明一个分支的合法性；任何试图修改Merkle树的行为都会导致链上某个节点的不一致。

Merkle树，是一个包含父节点哈希指针的二叉树的数据结构。


**TODO：complete here**

比特币脚本语言有几个重要的局限性：

```
1. 缺少图灵完备性  就是说，尽管比特币脚本语言支持了一个大的计算自己，它没有做到几乎支持所有计算（即图灵完备。完备性Completeness是计算复杂性理论中的术语，如果一个语言的计算能力可以做到和图灵机等价，那么就称这个语言是图灵完备的）。它主要缺少的种类是循环，这么做是为了避免交易中发生死循环。
2. Value-blindness
3. 缺少状态
4. Blockchain-blindness
```

## 以太坊

以太坊的目的是合并并且改进脚本，代币，链上元协议的概念，允许开发者创建任意基于共识的，拥有伸缩性，标准化，特征完备的应用， 简化这些不同原型的开发难度和互操作难度。以太坊通过建立最终抽象基础层实现了上述目标：一个内置图灵完备的编程语言，允许任何人编写智能合约和去中心化应用，创建他们自己定义的任何所有权规则，交易形式和状态转移函数。一个裸骨架版本的namecoin可以用两行代码实现，其他像货币和信誉系统也可以在20行代码内实现。智能合约，加密“盒子”，即包含某些只在特定条件满足时才解锁的值，也可以在我们的平台实现，而且远超比特币脚本提供的能力，因为图灵完备性，value-awareness，blockchain-awareness和状态。

### 以太坊账户
在以太坊中，状态是由“账户”对象组成的，每个账户拥有一个20字节的地址和账户之间直接交易信息。一个以太坊账户包含四个字段：

 - nonce， 一个计数器，用于保证每个交易只被处理一次
 - ether余额
 - 交易码，可以为空
 - 存储量，默认是空

**Ether**（以太）是以太坊的主要内部加密燃料，被用来当做交易手续费。

一般地，有两种类型的账户：外部拥有的账户，通过私钥控制；合约账户，通过交易码控制。外部拥有的账户没有交易码，一个人可以通过创建并签名一笔交易来发送消息；合约账户中，每次合约账户收到消息，它的交易码开始生效，允许读写合约账户的内部存储，发送其他消息或者创建合约。

### 消息和交易
以太坊中的“**消息**”和比特币中的“交易”有些类似，但是有三个重要区别。第一，以太坊消息可以通过外部实体或者合约创建，而比特币交易只能内部创建。第二，以太坊消息有显式选项来包含数据。最后，如果是合约账户，以太坊消息可以选择返回一条响应，这意味着以太坊中的消息包含了函数的概念。

以太坊中的术语“**交易**”用来指从外部拥有的账户发送过来的存储着消息的签名数据包。交易包含消息的成分，一个用于区分发送者的签名，以太数量和发送数据的数量，还有两个值STARTGAS和GASPRICE。为了防止代码中出现指数爆炸和死循环，每个交易要求设置一个代码可以执行的最多计算步骤（包括初始消息和执行中的任何附加消息）的上限。如果一笔交易“用光了汽油”，除了手续费外，所有状态改变进行回滚，如果交易终止时，“还剩余一些汽油”，剩下的手续费会返回给发送方。还有一种分离的交易类型及其对应的消息类型，用于创建合约。合约地址基于账户nonce和交易数据计算得到。

消息机制的一个重要结果是以太坊的“一等公民”特性，即合约与外部账户有等同的能力，包括发送消息和创建其他账户。这就允许合约同时服务多种不同的角色：例如，一个人可能是一个去中心化组织（一个合约）的一员   **TODO：这段有点难以理解，稍后翻译**

### 以太坊状态转移函数

![以太坊状态转移函数][3]
 
 以太坊转移函数，APPLY(S,TX) -> S' 可以如下定义：
 
 1. 检查交易格式是否正确，签名是否合法，nonce是否匹配发送方账户的nonce。如果不是，返回错误
 2. 计算交易费 STARTGAS*GASPRICE, 通过签名决定发送地址。从发送账户的余额减去手续费，增加发送方的nonce。如果余额不足，返回错误
 3. 初始化GAS = STARTGAS，给交易中的每个字节拿出一定量的GAS。
 4. 从发送方的账户给接收方的账户转移交易额。如果接受方的账户还不存在，创建这个账户。如果接受方账户是一个合约，执行合约代码，直到合约完成或者用完燃料。
 5. 如果因为发送方没有足够的钱导致转移值失败，或者代码执行用完燃料，回滚除手续费以外所有的状态改变，并且将手续费添加到矿工账户中。
 6. 否则（即转移成功），将剩余燃料退回给发送方，将消耗燃料的手续费发送给矿工。

例如，假设合约代码是
```
 if !contact.storage[msg.date[0]]:
     contract.storage[msg.data[0]] = msg.data[1]
```

注意现实中合约代码用底层EVM代码写的。为了清晰，上面例子是用Serpent，我们的高级语言写的，它可以被编译成EVM代码。假设合约存储起始为空，发送的一笔交易包含：10个以太值，2000gas，0.001以太 gasprice，和两个数据字段[2, 'CHARLIE']。状态转移函数的过程如下：

 1. 检查交易，合法，格式正确
 2. 检查交易发送方发送了至少2000 * 0.001 = 2 以太。如果是，从发送方扣掉2以太。
 3. 初始化gas = 2000；假设交易有170字节，字节费是5，扣掉170 * 5 = 850 gas，还剩2000 - 850 = 1150 gas
 4. 从发送方扣掉交易额10以太，向合约账户加上这10以太。
 5. 执行代码。在本例中，检查索引是2的合约存储项是否使用。本利中没有使用，因此令存储的索引2位置的值为CHARLIE。假设这花费了187 gas，还剩下1150 - 187 = 963 gas
 6. 向发送方账户返还963 * 0.001 = 0.963以太，返回结果状态。


 



  [1]: https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png
  [2]: https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png
  [3]: http://static.zybuluo.com/renqHIT/q2601auasnd3ex3jknmoyf6e/%E4%B8%8B%E8%BD%BD.png
